
## Generator

```
function\* gen() {
  var y = yield x + 2;
  return y;
}
```
- generator函数返回的是个指针对象（即遍历器）g。
调用指针g.next()方法，会移动指针到generator内的某段代码语句，并执行。代码语句通过yeild关键字分段。换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。

- value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。

- next 方法还可以接受参数，这是向 Generator 函数体内输入数据。
```
function* gen(x){
  try {
    var y = yield x + 2;
  } catch (e){ 
    console.log(e);
  }
  return y;
}

var g = gen(1);
g.next();
g.throw（'出错了'）;
// 出错了
```

- Generator 函数体外，使用指针对象的 throw 方法抛出的错误，可以被函数体内的 try ... catch 代码块捕获。
**出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。**

## Thunk函数
编译器 - 传值调用 (call by value);传名调用 (call by name)

- 编译器的"传名调用"实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数。

```
function f(m){
  return m * 2;     
}

f(x + 5);

// 等同于

var thunk = function () {
  return x + 5;
};

function f(thunk){
  return thunk() * 2;
}
```
